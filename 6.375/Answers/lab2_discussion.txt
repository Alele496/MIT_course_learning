
1. In Problems 1-3, you have analyzed the areas and the critical-path delays of di erent Bluespec
 FFT designs using synth. How does the area and critical-path delay of the mkFFT module
 change for combinational, linear and circular designs? Please explain to your observation.
 Which design(s) would give you the highest throughput if all FFT designs were running at the
 same clock frequency?
    Answer: Areas compare -> combinational(less Reg) < circular(Multiplex unit) < linear
            Cirtical Path Delay compare -> combinational > circular approximate equal to linear.
            Maximum throughput: linear assembly line. 
            Because the general throughput of assembly lines is very high, linear assembly lines use more resources, so it is faster.

 
2. Answer the three questions given in Problem 5 where we implemented polymorphic FIR lters.
    Change your FIR lter to take a variable length vector of coe cients as a module
 parameter. Run simulation to check if the module is working. What do you have to do now to
 instantiate a 4 tap FIR lter? A 256 tap FIR lter? Will your FIR lter behave correctly in those
 cases?
    Answer: Vector#(4, FixedPoint#(16,16)) coeffs = replicate(0.1);
            AudioProcessor fir <- mkFIRFilter(coeffs);

            Vector#(256, FixedPoint#(16,16)) coeffs_256tap = genCoeffs(256);
            AudioProcessor fir_256tap <- mkFIRFilter(coeffs_256tap);


3. Before you made your FFT implementations polymorphic, the number of points and data
 type was speci ed with global typedefs. What are the advantages of making the interface and
 modules polymorphic instead of just using typedefs? Are there any disadvantages to making
 the interfaces and modules polymorphic?
    Answer: The parameter configuration is flexible, but relatively complicated.

 
4. Now that your FFT can be fully separated from the AudioPipeline, it makes sense to test the
 FFT modules independently. Describe in detail (two or three paragraphs is appropriate) how
 you can test your FFT implementations independently from the rest of the AudioPipeline.
 Are your FFT implementations correct for both larger and smaller number of points than 8?
 Is it any easier to test the FFT implementations because they are polymorphic?
    Answer: Instantiate, then test the vector generation, and finally check and compare with the expected results.
            It should be correct. Polymorphization is generally more convenient to test. 
            It can be arbitrarily valued as long as it is within the constraint.
